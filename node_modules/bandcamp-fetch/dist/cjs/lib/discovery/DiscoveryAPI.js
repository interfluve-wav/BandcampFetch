"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LimiterDiscoveryAPI_limiter;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimiterDiscoveryAPI = void 0;
const BaseAPIWithImageSupport_js_1 = __importDefault(require("../common/BaseAPIWithImageSupport.js"));
const Cache_js_1 = require("../utils/Cache.js");
const Constants_js_1 = require("../utils/Constants.js");
const Fetcher_js_1 = require("../utils/Fetcher.js");
const DiscoverOptionsParser_js_1 = __importDefault(require("./DiscoverOptionsParser.js"));
const DiscoverResultParser_js_1 = __importDefault(require("./DiscoverResultParser.js"));
class DiscoveryAPI extends BaseAPIWithImageSupport_js_1.default {
    async getAvailableOptions() {
        return this.cache.getOrSet(Cache_js_1.CacheDataType.Constants, 'discoverOptions', async () => {
            const html = await this.fetch(Constants_js_1.URLS.SITE_URL);
            return DiscoverOptionsParser_js_1.default.parseOptions(html);
        });
    }
    async sanitizeDiscoverParams(params) {
        const options = await this.getAvailableOptions();
        const _getOptionValue = (optArr, value, defaultIndex = 0) => {
            if (value !== undefined && optArr) {
                const opt = optArr.find((o) => o.value == value);
                if (opt) {
                    return opt.value;
                }
            }
            if (optArr) {
                return optArr[defaultIndex].value;
            }
            return undefined;
        };
        const sanitized = {
            genre: _getOptionValue(options.genres, params?.genre),
            sortBy: _getOptionValue(options.sortBys, params?.sortBy),
            page: params?.page || 0
        };
        if (sanitized.sortBy !== 'rec' && sanitized.genre) {
            // Following only available when sortBy is not 'rec' (artist-recommend)
            const subgenreOptions = options.subgenres[sanitized.genre];
            if (subgenreOptions) { // `false` if genre is 'all'
                sanitized.subgenre = _getOptionValue(subgenreOptions, params?.subgenre);
            }
            // 'Time' option only available when there is effectively no subgenre (e.g. genre is 'all' or subgenre is 'all-metal')
            const timeAllowed = sanitized.subgenre === undefined || sanitized.subgenre == subgenreOptions[0].value;
            if (timeAllowed) {
                sanitized.time = _getOptionValue(options.times, params?.time, 1);
            }
            sanitized.location = _getOptionValue(options.locations, params?.location);
            sanitized.format = _getOptionValue(options.formats, params?.format);
        }
        else {
            sanitized.artistRecommendationType = _getOptionValue(options.artistRecommendationTypes, params?.artistRecommendationType);
        }
        return sanitized;
    }
    async discover(params) {
        const imageConstants = await this.imageAPI.getConstants();
        const opts = {
            imageBaseUrl: imageConstants.baseUrl,
            albumImageFormat: await this.imageAPI.getFormat(params?.albumImageFormat, 9),
            artistImageFormat: await this.imageAPI.getFormat(params?.artistImageFormat, 21)
        };
        const sanitizedParams = await this.sanitizeDiscoverParams(params);
        const resultParams = { ...sanitizedParams };
        // Passing an 'all' type subgenre (e.g. 'all-metal') in the discover url
        // Actually returns far fewer / zero results than without.
        // The Bandcamp site also does not seem to include it in its discover requests...
        if (sanitizedParams.time !== undefined) {
            // If 'time' exists in sanitized params, then we have an 'all' type subgenre
            // - refer to sanitizeDiscoverParams()
            delete sanitizedParams.subgenre;
        }
        const payload = DiscoveryAPI.getDiscoverRequestPayload(sanitizedParams);
        const json = await this.fetch(Constants_js_1.URLS.DISCOVER_URL, true, Fetcher_js_1.FetchMethod.GET, payload);
        return DiscoverResultParser_js_1.default.parseDiscoverResult(json, opts, resultParams);
    }
    /**
     * @internal
     */
    static getDiscoverRequestPayload(params) {
        const result = {
            s: params.sortBy || 'top',
            p: params.page || 0
        };
        if (params.genre) {
            result.g = params.genre;
            if (params.subgenre) {
                result.t = params.subgenre;
            }
        }
        if (params.location !== undefined) {
            result.gn = params.location;
        }
        if (params.format) {
            result.f = params.format;
        }
        if (result.s === 'rec' && params.artistRecommendationType) {
            result.r = params.artistRecommendationType;
        }
        if (params.time !== undefined) {
            result.w = params.time;
        }
        return result;
    }
}
exports.default = DiscoveryAPI;
class LimiterDiscoveryAPI extends DiscoveryAPI {
    constructor(params) {
        super(params);
        _LimiterDiscoveryAPI_limiter.set(this, void 0);
        __classPrivateFieldSet(this, _LimiterDiscoveryAPI_limiter, params.limiter, "f");
    }
    async getAvailableOptions() {
        return __classPrivateFieldGet(this, _LimiterDiscoveryAPI_limiter, "f").schedule(() => super.getAvailableOptions());
    }
    async sanitizeDiscoverParams(params) {
        return __classPrivateFieldGet(this, _LimiterDiscoveryAPI_limiter, "f").schedule(() => super.sanitizeDiscoverParams(params));
    }
    async discover(params) {
        return __classPrivateFieldGet(this, _LimiterDiscoveryAPI_limiter, "f").schedule(() => super.discover(params));
    }
}
exports.LimiterDiscoveryAPI = LimiterDiscoveryAPI;
_LimiterDiscoveryAPI_limiter = new WeakMap();
//# sourceMappingURL=DiscoveryAPI.js.map