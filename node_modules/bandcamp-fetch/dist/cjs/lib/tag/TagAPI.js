"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _LimiterTagAPI_limiter;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimiterTagAPI = void 0;
const BaseAPIWithImageSupport_js_1 = __importDefault(require("../common/BaseAPIWithImageSupport.js"));
const Constants_js_1 = require("../utils/Constants.js");
const Fetcher_js_1 = require("../utils/Fetcher.js");
const Parse_js_1 = require("../utils/Parse.js");
const AlbumHighlightsByTagParser_js_1 = __importDefault(require("./AlbumHighlightsByTagParser.js"));
const ReleasesByTagParser_js_1 = __importDefault(require("./ReleasesByTagParser.js"));
const TagInfoParser_js_1 = __importDefault(require("./TagInfoParser.js"));
const TagListParser_js_1 = __importDefault(require("./TagListParser.js"));
class TagAPI extends BaseAPIWithImageSupport_js_1.default {
    async list() {
        const html = await this.fetch((0, Parse_js_1.normalizeUrl)('tags'));
        return TagListParser_js_1.default.parseTags(html);
    }
    async getInfo(tagUrl) {
        const html = await this.fetch(tagUrl);
        return TagInfoParser_js_1.default.parseInfo(html, tagUrl);
    }
    async getAlbumHighlights(params) {
        const imageConstants = await this.imageAPI.getConstants();
        const opts = {
            imageBaseUrl: imageConstants.baseUrl,
            imageFormat: await this.imageAPI.getFormat(params.imageFormat, 9)
        };
        const html = await this.fetch(params.tagUrl);
        return AlbumHighlightsByTagParser_js_1.default.parseHighlights(html, opts);
    }
    async getReleasesAvailableFilters(tagUrl) {
        const filterValueNames = await this.getReleaseFilterValueNames(tagUrl);
        const html = await this.fetch(tagUrl);
        return ReleasesByTagParser_js_1.default.parseFilters(html, filterValueNames);
    }
    async getReleases(params) {
        const imageConstants = await this.imageAPI.getConstants();
        const opts = {
            imageBaseUrl: imageConstants.baseUrl,
            imageFormat: await this.imageAPI.getFormat(params.imageFormat, 9)
        };
        const _getDefaultFilters = async (tagUrl) => {
            if (params.useHardcodedDefaultFilters) {
                let tagUrlPath = (0, Parse_js_1.splitUrl)(tagUrl).path;
                if (tagUrlPath.endsWith('/')) {
                    tagUrlPath = tagUrlPath.substring(0, tagUrlPath.length - 1);
                }
                const tagValue = tagUrlPath.split('/').pop();
                return Promise.resolve({
                    tags: [tagValue],
                    location: 0,
                    format: 'all',
                    sort: 'pop'
                });
            }
            const filterOptions = await this.getReleasesAvailableFilters(tagUrl);
            const defaultFilters = {};
            filterOptions.forEach((filter) => {
                const selectedOption = filter.options.find((o) => o.selected);
                const defaultOption = filter.options.find((o) => o.default);
                if (selectedOption) {
                    if (filter.name === 'tags') {
                        defaultFilters[filter.name] = [selectedOption.value];
                    }
                    else {
                        defaultFilters[filter.name] = selectedOption.value;
                    }
                }
                else if (defaultOption) {
                    defaultFilters[filter.name] = defaultOption.value;
                }
            });
            return defaultFilters;
        };
        const defaultFilters = await _getDefaultFilters(params.tagUrl);
        const tagsFilter = Array.isArray(defaultFilters.tags) ? [...defaultFilters.tags] : [];
        if (params?.filters?.tags && Array.isArray(params.filters.tags)) {
            params.filters.tags.forEach((tag) => {
                if (!tagsFilter.includes(tag)) {
                    tagsFilter.push(tag);
                }
            });
        }
        const paramFilters = params.filters ? {
            ...defaultFilters,
            ...params.filters,
            tags: tagsFilter
        } : defaultFilters;
        const postData = {
            filters: paramFilters,
            page: params.page || 1
        };
        const json = await this.fetch(Constants_js_1.URLS.DIG_DEEPER, true, Fetcher_js_1.FetchMethod.POST, postData);
        return ReleasesByTagParser_js_1.default.parseReleases(json, opts);
    }
    /**
     * @internal
     */
    async getReleaseFilterValueNames(tagUrl) {
        const url = `${tagUrl}?tab=all_releases`;
        const html = await this.fetch(url);
        const path = ReleasesByTagParser_js_1.default.parseHubJSPath(html);
        if (!path) {
            throw new Parse_js_1.ParseError(`Failed to obtain Hub JS path from ${url}`, html);
        }
        const js = await this.fetch(path);
        try {
            return ReleasesByTagParser_js_1.default.parseHubJSFilterValueNames(js);
        }
        catch (error) {
            throw new Parse_js_1.ParseError('Failed to obtain filter names / values from Hub JS', js, error);
        }
    }
}
exports.default = TagAPI;
class LimiterTagAPI extends TagAPI {
    constructor(params) {
        super(params);
        _LimiterTagAPI_limiter.set(this, void 0);
        __classPrivateFieldSet(this, _LimiterTagAPI_limiter, params.limiter, "f");
    }
    async list() {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.list());
    }
    async getInfo(tagUrl) {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.getInfo(tagUrl));
    }
    async getAlbumHighlights(params) {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.getAlbumHighlights(params));
    }
    async getReleasesAvailableFilters(tagUrl) {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.getReleasesAvailableFilters(tagUrl));
    }
    async getReleases(params) {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.getReleases(params));
    }
}
exports.LimiterTagAPI = LimiterTagAPI;
_LimiterTagAPI_limiter = new WeakMap();
//# sourceMappingURL=TagAPI.js.map