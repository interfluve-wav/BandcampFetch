var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LimiterTagAPI_limiter;
import BaseAPIWithImageSupport from '../common/BaseAPIWithImageSupport.js';
import { URLS } from '../utils/Constants.js';
import { FetchMethod } from '../utils/Fetcher.js';
import { ParseError, normalizeUrl, splitUrl } from '../utils/Parse.js';
import AlbumHighlightsByTagParser from './AlbumHighlightsByTagParser.js';
import ReleasesByTagParser from './ReleasesByTagParser.js';
import TagInfoParser from './TagInfoParser.js';
import TagListParser from './TagListParser.js';
export default class TagAPI extends BaseAPIWithImageSupport {
    async list() {
        const html = await this.fetch(normalizeUrl('tags'));
        return TagListParser.parseTags(html);
    }
    async getInfo(tagUrl) {
        const html = await this.fetch(tagUrl);
        return TagInfoParser.parseInfo(html, tagUrl);
    }
    async getAlbumHighlights(params) {
        const imageConstants = await this.imageAPI.getConstants();
        const opts = {
            imageBaseUrl: imageConstants.baseUrl,
            imageFormat: await this.imageAPI.getFormat(params.imageFormat, 9)
        };
        const html = await this.fetch(params.tagUrl);
        return AlbumHighlightsByTagParser.parseHighlights(html, opts);
    }
    async getReleasesAvailableFilters(tagUrl) {
        const filterValueNames = await this.getReleaseFilterValueNames(tagUrl);
        const html = await this.fetch(tagUrl);
        return ReleasesByTagParser.parseFilters(html, filterValueNames);
    }
    async getReleases(params) {
        const imageConstants = await this.imageAPI.getConstants();
        const opts = {
            imageBaseUrl: imageConstants.baseUrl,
            imageFormat: await this.imageAPI.getFormat(params.imageFormat, 9)
        };
        const _getDefaultFilters = async (tagUrl) => {
            if (params.useHardcodedDefaultFilters) {
                let tagUrlPath = splitUrl(tagUrl).path;
                if (tagUrlPath.endsWith('/')) {
                    tagUrlPath = tagUrlPath.substring(0, tagUrlPath.length - 1);
                }
                const tagValue = tagUrlPath.split('/').pop();
                return Promise.resolve({
                    tags: [tagValue],
                    location: 0,
                    format: 'all',
                    sort: 'pop'
                });
            }
            const filterOptions = await this.getReleasesAvailableFilters(tagUrl);
            const defaultFilters = {};
            filterOptions.forEach((filter) => {
                const selectedOption = filter.options.find((o) => o.selected);
                const defaultOption = filter.options.find((o) => o.default);
                if (selectedOption) {
                    if (filter.name === 'tags') {
                        defaultFilters[filter.name] = [selectedOption.value];
                    }
                    else {
                        defaultFilters[filter.name] = selectedOption.value;
                    }
                }
                else if (defaultOption) {
                    defaultFilters[filter.name] = defaultOption.value;
                }
            });
            return defaultFilters;
        };
        const defaultFilters = await _getDefaultFilters(params.tagUrl);
        const tagsFilter = Array.isArray(defaultFilters.tags) ? [...defaultFilters.tags] : [];
        if (params?.filters?.tags && Array.isArray(params.filters.tags)) {
            params.filters.tags.forEach((tag) => {
                if (!tagsFilter.includes(tag)) {
                    tagsFilter.push(tag);
                }
            });
        }
        const paramFilters = params.filters ? {
            ...defaultFilters,
            ...params.filters,
            tags: tagsFilter
        } : defaultFilters;
        const postData = {
            filters: paramFilters,
            page: params.page || 1
        };
        const json = await this.fetch(URLS.DIG_DEEPER, true, FetchMethod.POST, postData);
        return ReleasesByTagParser.parseReleases(json, opts);
    }
    /**
     * @internal
     */
    async getReleaseFilterValueNames(tagUrl) {
        const url = `${tagUrl}?tab=all_releases`;
        const html = await this.fetch(url);
        const path = ReleasesByTagParser.parseHubJSPath(html);
        if (!path) {
            throw new ParseError(`Failed to obtain Hub JS path from ${url}`, html);
        }
        const js = await this.fetch(path);
        try {
            return ReleasesByTagParser.parseHubJSFilterValueNames(js);
        }
        catch (error) {
            throw new ParseError('Failed to obtain filter names / values from Hub JS', js, error);
        }
    }
}
export class LimiterTagAPI extends TagAPI {
    constructor(params) {
        super(params);
        _LimiterTagAPI_limiter.set(this, void 0);
        __classPrivateFieldSet(this, _LimiterTagAPI_limiter, params.limiter, "f");
    }
    async list() {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.list());
    }
    async getInfo(tagUrl) {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.getInfo(tagUrl));
    }
    async getAlbumHighlights(params) {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.getAlbumHighlights(params));
    }
    async getReleasesAvailableFilters(tagUrl) {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.getReleasesAvailableFilters(tagUrl));
    }
    async getReleases(params) {
        return __classPrivateFieldGet(this, _LimiterTagAPI_limiter, "f").schedule(() => super.getReleases(params));
    }
}
_LimiterTagAPI_limiter = new WeakMap();
//# sourceMappingURL=TagAPI.js.map